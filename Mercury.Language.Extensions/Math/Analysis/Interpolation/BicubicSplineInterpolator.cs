// Copyright (c) 2017 - presented by Kei Nakai
//
// Original project is developed and published by OpenGamma Inc.
//
// Copyright (C) 2012 - present by OpenGamma Incd and the OpenGamma group of companies
//
// Please see distribution for license.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
//     
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mercury.Language.Math;

using Mercury.Language.Math.Analysis.Function;
using Mercury.Language.Math.Analysis.Polynomial;
using Mercury.Language.Exception;


namespace Mercury.Language.Math.Analysis.Interpolation
{
    /// <summary>
    /// Generates a bicubic interpolating function.
    /// 
    /// @version $Revision: 980944 $ $Date: 2010-07-30 22:31:11 +0200 (vend 30 juild 2010) $
    /// @since 2.2
    /// </summary>
    public class BicubicSplineInterpolator : IBivariateRealGridInterpolator
    {
        /// <summary>
        /// {@inheritDoc}
        /// </summary>
        public virtual IBivariateRealFunction Interpolate(double[] xval,
                                                              double[] yval,
                                                              double[][] fval)
        {
            if (xval.Length == 0 || yval.Length == 0 || fval.Length == 0)
            {
                throw new DataNotFoundException(LocalizedResources.Instance().NO_DATA);
            }
            if (xval.Length != fval.Length)
            {
                throw new DimensionMismatchException(xval.Length, fval.Length);
            }

            Math2.CheckOrder(xval);
            Math2.CheckOrder(yval);

            int xLen = xval.Length;
            int yLen = yval.Length;

            // Samples (first index is y-coordinate, i.ed subarray variable is x)
            // 0 <= i < xval.Length
            // 0 <= j < yval.Length
            // fX[j][i] = f(xval[i], yval[j])
            double[][] fX = ArrayUtility.CreateJaggedArray<double>(yLen, xLen);
            AutoParallel.AutoParallelFor(0, xLen, (i) =>
           {
               if (fval[i].Length != yLen)
               {
                   throw new DimensionMismatchException(fval[i].Length, yLen);
               }

               AutoParallel.AutoParallelFor(0, yLen, (j) =>
               {
                   fX[j][i] = fval[i][j];
               });
           });

            SplineInterpolator spInterpolator = new SplineInterpolator();

            // For each line y[j] (0 <= j < yLen), construct a 1D spline with
            // respect to variable x
            PolynomialSplineFunction[] ySplineX = new PolynomialSplineFunction[yLen];
            AutoParallel.AutoParallelFor(0, yLen, (j) =>
            {
                ySplineX[j] = (PolynomialSplineFunction)spInterpolator.Interpolate(xval, fX[j]);
            });

            // For each line x[i] (0 <= i < xLen), construct a 1D spline with
            // respect to variable y generated by array fY_1[i]
            PolynomialSplineFunction[] xSplineY = new PolynomialSplineFunction[xLen];
            AutoParallel.AutoParallelFor(0, xLen, (i) =>
            {
                xSplineY[i] = (PolynomialSplineFunction)spInterpolator.Interpolate(yval, fval[i]);
            });

            // Partial derivatives with respect to x at the grid knots
            double[][] dFdX = ArrayUtility.CreateJaggedArray<double>(xLen, yLen);
            AutoParallel.AutoParallelFor(0, yLen, (j) =>
            {
                IUnivariateRealFunction f = ySplineX[j].Derivative();
                AutoParallel.AutoParallelFor(0, xLen, (i) =>
                {
                    dFdX[i][j] = f.Value(xval[i]);
                });
            });

            // Partial derivatives with respect to y at the grid knots
            double[][] dFdY = ArrayUtility.CreateJaggedArray<double>(xLen, yLen);
            AutoParallel.AutoParallelFor(0, xLen, (i) =>
            {
                IUnivariateRealFunction f = xSplineY[i].Derivative();
                AutoParallel.AutoParallelFor(0, yLen, (j) =>
                {
                    dFdY[i][j] = f.Value(yval[j]);
                });
            });

            // Cross partial derivatives
            double[][] d2FdXdY = ArrayUtility.CreateJaggedArray<double>(xLen, yLen);
            AutoParallel.AutoParallelFor(0, xLen, (i) =>
            {
                int nI = nextIndex(i, xLen);
                int pI = previousIndex(i);
                AutoParallel.AutoParallelFor(0, yLen, (j) =>
                {
                    int nJ = nextIndex(j, yLen);
                    int pJ = previousIndex(j);
                    d2FdXdY[i][j] = (fval[nI][nJ] - fval[nI][pJ] -
                                     fval[pI][nJ] + fval[pI][pJ]) /
                        ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]));
                });
            });

            // Create the interpolating splines
            return new BicubicSplineInterpolatingFunction(xval, yval, fval,
                                                          dFdX, dFdY, d2FdXdY);
        }

        /// <summary>
        /// Compute the next index of an array, clipping if necessary.
        /// It is assumed (but not checked) that {@code i} is larger than or equal to 0}.
        /// 
        /// </summary>
        /// <param Name="i">Index</param>
        /// <param Name="max">Upper limit of the array</param>
        /// <returns>the next index</returns>
        private int nextIndex(int i, int max)
        {
            int index = i + 1;
            return index < max ? index : index - 1;
        }
        /// <summary>
        /// Compute the previous index of an array, clipping if necessary.
        /// It is assumed (but not checked) that {@code i} is smaller than the size of the array.
        /// 
        /// </summary>
        /// <param Name="i">Index</param>
        /// <returns>the previous index</returns>
        private int previousIndex(int i)
        {
            int index = i - 1;
            return index >= 0 ? index : 0;
        }
    }
}
